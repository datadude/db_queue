<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Db queue : A Ruby library enabling the threaded processing from a database query or cached file. ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Db queue</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/datadude/db_queue">View on GitHub</a>

          <h1 id="project_title">Db queue</h1>
          <h2 id="project_tagline">A Ruby library enabling the threaded processing from a database query or cached file. </h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/datadude/db_queue/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/datadude/db_queue/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="db-queue" class="anchor" href="#db-queue" aria-hidden="true"><span class="octicon octicon-link"></span></a>DB Queue</h1>

<p>An easy threaded work queue.</p>

<h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>Suppose that you have a process that you want to perform for thousands of database records.
Think sending emails, or performing complex calculations or transformations that take a large amount of time.
You probably want to fire off a process and walk away from it.  I had just such a task, the process was going
to take 15 seconds or more and  I had 18,000 records to process. Testing indicated that to complete the task I
would need something like 36 hours!</p>

<p>I did not want to keep a database connection open that long, and if something happened I would want to be able to
pick up where I left off and complete the task. Enter the DB Queue!</p>

<h3>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h3>

<ul>
<li>Easy queue creation using active record, a text file or a SQL query.</li>
<li>Logging of each item processed, and a separate log for errors.</li>
<li>Saves its place in the queue to file.</li>
<li>Uses fairly human readable text files to cache.</li>
<li>Tracks successes and failures</li>
<li>Threaded processing.</li>
</ul>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>Depends on Standard RAILS components Active Record and Logger.
Plus any Active record adapter that you might need.
It has been tested with Mysql2 and FireBird adapters.</p>

<h2>
<a id="quickstart" class="anchor" href="#quickstart" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quickstart</h2>

<p>Start by simply cloning this project:</p>

<pre><code>     git clone https://github.com/datadude/db_queue
</code></pre>

<p>Then set up your database connection in the <code>envirionment.rb</code></p>

<div class="highlight highlight-ruby"><pre><span class="pl-s3">ActiveRecord</span>::<span class="pl-s3">Base</span>.establish_connection(
    <span class="pl-c1">:adapter</span>=&gt; <span class="pl-s1"><span class="pl-pds">"</span>mysql2<span class="pl-pds">"</span></span>,
    <span class="pl-c1">:host</span> =&gt; <span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>,
    <span class="pl-c1">:database</span>=&gt; <span class="pl-s1"><span class="pl-pds">"</span>my_users<span class="pl-pds">"</span></span>,
    <span class="pl-c1">:username</span> =&gt; <span class="pl-s1"><span class="pl-pds">'</span>test_user<span class="pl-pds">'</span></span>,
    <span class="pl-c1">:password</span> =&gt; <span class="pl-s1"><span class="pl-pds">'</span>secretpassword<span class="pl-pds">'</span></span>
)</pre></div>

<p>consider doing the same in <code>envirionment_test.rb</code> if you wish to run tests.</p>

<p>Now write your processing code in a <code>.rb</code> file. You can find an example in <code>mail_users.rb</code>.
The following steps are needed to start the queue:
1. put the code you wish to run for each row of a query or file in a <strong>lambda</strong> and assign it to a variable.
2. Create or connect ot a <code>SqlCache</code> file.  That contains rows of the data you wish to process.
3. Create a new DbQueue object passing in the <code>SQLCache</code> file, the lambda from step 1, and any configuration params
4. Call .run for the DbQueue instance, this will kick off the processing. firing off the number of threads configured
(2 by default). control will return once processing is complete.</p>

<h2>
<a id="documentation" class="anchor" href="#documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation</h2>

<h3>
<a id="sqlcache" class="anchor" href="#sqlcache" aria-hidden="true"><span class="octicon octicon-link"></span></a>SqlCache</h3>

<h4>
<a id="sqlcacheread_cache_filefilename" class="anchor" href="#sqlcacheread_cache_filefilename" aria-hidden="true"><span class="octicon octicon-link"></span></a>SqlCache.read_cache_file(filename)</h4>

<p>class method to return a <code>SqlCacheFile</code> given a file that has already been produced.  Connects to that file and scrolls 
to the line number stored in the <em>__place.txt_</em> cache file.  use this to re-open a cached file.</p>

<h4>
<a id="sqlcachecache_by_sqlfilenamesql" class="anchor" href="#sqlcachecache_by_sqlfilenamesql" aria-hidden="true"><span class="octicon octicon-link"></span></a>SqlCache.cache_by_sql(filename,sql)</h4>

<p>class method to return a <code>SqlCacheFile</code> given arbitrary sql.  Uses ActiveRecord to connect to the database and run 
<code>find_by_sql</code>. Use this to create a new cache file.</p>

<h4>
<a id="sqlcacheactiverecord_relation-cache_resultfilename" class="anchor" href="#sqlcacheactiverecord_relation-cache_resultfilename" aria-hidden="true"><span class="octicon octicon-link"></span></a>SqlCache::ActiveRecord_Relation cache_result(filename)</h4>

<p>You can also call <code>cache_result(filename)</code> oonthe resultset returned from a 'find' or '.all' query </p>

<h3>
<a id="sqlcachefile" class="anchor" href="#sqlcachefile" aria-hidden="true"><span class="octicon octicon-link"></span></a>SqlCacheFile</h3>

<h4>
<a id="sqlcachefilenewfilenameresult_setnil" class="anchor" href="#sqlcachefilenewfilenameresult_setnil" aria-hidden="true"><span class="octicon octicon-link"></span></a>SqlCacheFile.new(filename,result_set=nil)</h4>

<p>result_set can be an ActiveRecord_Relation, or an array of hashes.</p>

<h4>
<a id="instance-methods" class="anchor" href="#instance-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>instance methods:</h4>

<ul>
<li>
<strong>lineno</strong>: returns the value in place_cachefilename.txt </li>
<li>
<strong>lineno=</strong>: sets the place in the file. </li>
<li>
<strong>reset_place</strong>: sets lineno=0</li>
<li>
<strong>next_line</strong>: returns the <strong>current</strong> line and increments the pointer to the next line. </li>
</ul>

<h3>
<a id="dbqueue" class="anchor" href="#dbqueue" aria-hidden="true"><span class="octicon octicon-link"></span></a>DbQueue</h3>

<h4>
<a id="dbqueuenewcache_filecallbackparams" class="anchor" href="#dbqueuenewcache_filecallbackparams" aria-hidden="true"><span class="octicon octicon-link"></span></a>DbQueue.new(cache_file,callback,params={})</h4>

<p><em>cache_file</em> needs to be an instance of <code>SQLCacheFile</code>, <em>callback</em> needs to be a proc or lambda containing the code to be run for each row.  It is called with the row parameter, <em>row</em> should be a hash. </p>

<h5>
<a id="params" class="anchor" href="#params" aria-hidden="true"><span class="octicon octicon-link"></span></a>params</h5>

<ul>
<li>
<strong>log_file</strong>: location and name for the logfile, defaults to <code>"#{Root_dir}/log/db_queue.log"</code>.</li>
<li>
<strong>error_log_file</strong>: location and name for the logfile, defaults to <code>"#{Root_dir}/log/db_queue_error.log'"</code>
</li>
<li>
<strong>id_column</strong>: sets the "primary key" for your data set defaluts to 'id' mostly used for logging.</li>
<li>
<strong>do_reset</strong>: resets the pointer for the SQLCache file to the begining defaults to false,  mostly not needed.</li>
<li>
<strong>threads</strong>: sets the number of threads that will work on processing your queue defaults to 2.</li>
<li>
<strong>include_backtrace</strong>: include the backtrace in the error log, defaults to false.
#### instance methods:</li>
<li>
<strong>run</strong>: fires off the threads to process the queue.  the program "waits" until all processing has been completed.</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Db queue maintained by <a href="https://github.com/datadude">datadude</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
