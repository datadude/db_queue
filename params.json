{"name":"Db queue","tagline":"A Ruby library enabling the threaded processing from a database query or cached file. ","body":"#DB Queue\r\nAn easy threaded work queue.\r\n\r\n##Introduction\r\nSuppose that you have a process that you want to perform for thousands of database records.\r\nThink sending emails, or performing complex calculations or transformations that take a large amount of time.\r\nYou probably want to fire off a process and walk away from it.  I had just such a task, the process was going\r\nto take 15 seconds or more and  I had 18,000 records to process. Testing indicated that to complete the task I\r\nwould need something like 36 hours!\r\n\r\nI did not want to keep a database connection open that long, and if something happened I would want to be able to\r\npick up where I left off and complete the task. Enter the DB Queue!\r\n\r\n###Features\r\n* Easy queue creation using active record, a text file or a SQL query.\r\n* Logging of each item processed, and a separate log for errors.\r\n* Saves its place in the queue to file.\r\n* Uses fairly human readable text files to cache.\r\n* Tracks successes and failures\r\n* Threaded processing.\r\n\r\n##Dependencies\r\nDepends on Standard RAILS components Active Record and Logger.\r\nPlus any Active record adapter that you might need.\r\nIt has been tested with Mysql2 and FireBird adapters.\r\n\r\n##Quickstart\r\nStart by simply cloning this project:\r\n```\r\n     git clone https://github.com/datadude/db_queue\r\n```\r\n\r\nThen set up your database connection in the `envirionment.rb`\r\n\r\n\r\n```ruby\r\nActiveRecord::Base.establish_connection(\r\n    :adapter=> \"mysql2\",\r\n    :host => \"localhost\",\r\n    :database=> \"my_users\",\r\n    :username => 'test_user',\r\n    :password => 'secretpassword'\r\n)\r\n```\r\nconsider doing the same in `envirionment_test.rb` if you wish to run tests.\r\n\r\n\r\nNow write your processing code in a `.rb` file. You can find an example in `mail_users.rb`.\r\nThe following steps are needed to start the queue:\r\n1. put the code you wish to run for each row of a query or file in a __lambda__ and assign it to a variable.\r\n2. Create or connect ot a `SqlCache` file.  That contains rows of the data you wish to process.\r\n3. Create a new DbQueue object passing in the `SQLCache` file, the lambda from step 1, and any configuration params\r\n4. Call .run for the DbQueue instance, this will kick off the processing. firing off the number of threads configured\r\n(2 by default). control will return once processing is complete.\r\n\r\n##Documentation\r\n\r\n###SqlCache\r\n#### SqlCache.read_cache_file(filename)\r\nclass method to return a `SqlCacheFile` given a file that has already been produced.  Connects to that file and scrolls \r\nto the line number stored in the ___place.txt__ cache file.  use this to re-open a cached file.\r\n#### SqlCache.cache_by_sql(filename,sql)\r\nclass method to return a `SqlCacheFile` given arbitrary sql.  Uses ActiveRecord to connect to the database and run \r\n`find_by_sql`. Use this to create a new cache file.\r\n#### SqlCache::ActiveRecord_Relation cache_result(filename)\r\nYou can also call `cache_result(filename)` oonthe resultset returned from a 'find' or '.all' query \r\n\r\n\r\n###SqlCacheFile\r\n####SqlCacheFile.new(filename,result_set=nil)\r\nresult_set can be an ActiveRecord_Relation, or an array of hashes.\r\n####instance methods:\r\n* lineno: returns the value in place_cachefilename.txt \r\n* lineno=: sets the place in the file. \r\n* reset_place: sets lineno=0\r\n* next_line: returns the __current__ line and increments the pointer to the next line. \r\n\r\n\r\n###DbQueue\r\n####DbQueue.new(cache_file,callback,params={})\r\n*cache_file* needs to be an instance of `SQLCacheFile`, *callback* needs to be a proc or lambda containing the code to be run for each row.  It is called with the row parameter, *row* should be a hash. \r\n##### params\r\n* **log_file**: location and name for the logfile, defaults to `\"#{Root_dir}/log/db_queue.log\"`.\r\n* **error_log_file**: location and name for the logfile, defaults to `\"#{Root_dir}/log/db_queue_error.log'\"`\r\n* **id_column**: sets the \"primary key\" for your data set defaluts to 'id' mostly used for logging.\r\n* **do_reset**: resets the pointer for the SQLCache file to the begining defaults to false,  mostly not needed.\r\n* **threads**: sets the number of threads that will work on processing your queue defaults to 2.\r\n* **include_backtrace**: include the backtrace in the error log, defaults to false.\r\n#### instance methods:\r\n* run: fires off the threads to process the queue.  the program \"waits\" until all processing has been completed.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}