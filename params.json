{"name":"Db queue","tagline":"A Ruby library enabling the threaded processing from a database query or cached file. ","body":"#DB Queue\r\nAn easy threaded work queue.\r\n\r\n##Introduction\r\nSuppose that you have a process that you want to perform for thousands of database records.\r\nThink sending emails, or performing complex calculations or transformations that take a large amount of time.\r\nYou probably want to fire off a process and walk away from it.  I had just such a task, the process was going\r\nto take 15 seconds or more and  I had 18,000 records to process. Testing indicated that to complete the task I\r\nwould need something like 36 hours!\r\n\r\nI did not want to keep a database connection open that long, and if something happened I would want to be able to\r\npick up where I left off and complete the task. Enter the DB Queue!\r\n\r\n###Features\r\n* Easy queue creation using active record, a text file or a SQL query.\r\n* Logging of each item processed, and a separate log for errors.\r\n* Saves its place in the queue to file.\r\n* Uses fairly human readable text files to cache.\r\n* Tracks successes and failures\r\n* Threaded processing.\r\n\r\n##Dependencies\r\nDepends on Standard RAILS components Active Record and Logger.\r\nPlus any Active record adapter that you might need.\r\nIt has been tested with Mysql2 and FireBird adapters.\r\n\r\n##Quickstart\r\nStart by simply cloning this project:\r\n```\r\n     git clone https://github.com/datadude/db_queue\r\n```\r\n\r\nThen set up your database connection in the `envirionment.rb`\r\n\r\n\r\n```ruby\r\nActiveRecord::Base.establish_connection(\r\n    :adapter=> \"mysql2\",\r\n    :host => \"localhost\",\r\n    :database=> \"my_users\",\r\n    :username => 'test_user',\r\n    :password => 'secretpassword'\r\n)\r\n```\r\nconsider doing the same in `envirionment_test.rb` if you wish to run tests.\r\n\r\n\r\nNow write your processing code in a `.rb` file. You can find an example in `mail_users.rb`.\r\nThe following steps are needed to start the queue:\r\n1. put the code you wish to run for each row of a query or file in a __lambda__ and assign it to a variable.\r\n2. Create or connect ot a `SqlCache` file.  That contains rows of the data you wish to process.\r\n3. Create a new DbQueue object passing in the `SQLCache` file, the lambda from step 1, and any configuration params\r\n4. Call .run for the DbQueue instance, this will kick off the processing. firing off the number of threads configured\r\n(2 by default). control will return once processing is complete.\r\n\r\n##Documentation\r\n\r\n###SqlCache\r\n#### SqlCache.read_cache_file(filename)\r\nclass method to return a `SqlCacheFile` given a file that has already been produced.  Connects to that file and scrolls \r\nto the line number stored in the ___place.txt__ cache file.  use this to re-open a cached file.\r\n#### SqlCache.cache_by_sql(filename,sql)\r\nclass method to return a `SqlCacheFile` given arbitrary sql.  Uses ActiveRecord to connect to the database and run \r\n`find_by_sql`. Use this to create a new cache file.\r\n#### SqlCache::ActiveRecord_Relation cache_result(filename)\r\nYou can also call `cache_result(filename)` oonthe resultset returned from a 'find' or '.all' query \r\n\r\n###SqlCacheFile\r\n####SqlCacheFile.new(filename,result_set=nil)\r\nresult_set can be an ActiveRecord_Relation, or an array of hashes.\r\n#####instance methods:\r\n* lineno\r\n* reset_place\r\n* \r\n\r\n###DbQueue\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}